This project needs a proper structure for a professional Python software development project with an automated CI/CD pipeline, testing and coding standards, coding assistant support, documentation and versioning. Hence, you are asked to complete the following:
- Create the directories ".amazonq", ".clinerules", ".clinerules/workflows", ".vscode", "cdk", "docs", "scripts", "src", "test" and "tmp" if they do not already exist
- Create a .gitignore file if it does not exist; if such a file exist, keep the information in it and modify the file so that it has the default entries that keeps generated files of a Python project out of the repository. Add the tmp folder to .gitignore. and all directory that contain AWS CDK related output in "cdk".
- setup a versioning system using systemtools-csm and an auto-generated file "src/_version.py" that serves as a single source of truth for the current version number. All other files must use this file for determining the current version and no other files where the version number is maintained are permitted.
- create requirements.txt and requirements-dev.txt files and analyze any files in "src" for potential dependencies. Adapt the content of these two files accordingly.
- Create a basic python package project file (toml) and all other files that are necessary for publishing Python code.
- Determine if this project's repo is on github, gitlab or some other repo hoster and setup a basic CI workflow with the following components depending on which repo hoster is used:
  - run the tests which are stored in "test/"; the target test coverage for this project is 80%, but the critical path of the application must be fully covered by tests.
  - modern coding standards are automatically checked (black, isort, flake8, mypy); note that generated files such as _version.py must be excluded from checks. We use a maximum code line length of 120 chars for this project. Ensure that this is reflected in the CI workflow.
  - run a security check using bandit
  - All of the three CI components above should be run (ideally, in parallel) and the CI workflow passes, if all of these tests pass. These checks must be run across all files containing code in "cdk", "src", "scripts" and "test"
  - update requirements.txt and similar files so that they contain the dependencies required for running CI workflows.
- If it does not exist, create a virtual environment "venv" for Python for this project. Create a settings.json in ".vscode" so that terminals are automatically started with an activated virtual environment.
- Ensure that all dependendencies listed in any of the requirements.txt files are installed in the virtual environment
- If it does not exist, create a file "docs/forLLMConsumption.md". This file contains project-relevant information in a format suitable for coding assistants.
- If it does not exist, create a file "docs/ProjectPlan.md". This file contains two main sections: 1. the overall project plan with milestones and key deliverables and 2. a section that lists "todos" that are left for future work as well as open issues.
- If it does not exist, create a file "docs/ProjectDesign.md". This file contains the main design principles and overall architecture of the project.
- Create the following files in ".clinerules" that contain rules for the coding assistant Cline (documentation of this feature is at "https://docs.cline.bot/features/cline-rules" - review this page before starting this step):
  - "use-venv.md": All command line commands must be executed inside the venv. No execution may happen without activated venv.
  - "no-tmp-files-in-root.md": Coding assistants that create intermediate files to organize/automate/streamline their work such as implementation plans, scripts or other such assets must store them in "tmp/". No such files must be stored in the root directory of the project or any other directory. More specifically, implementation plan documents created by Cline with the "/deep-planning" command must be stored on "tmp/" and cannot be stored anywhere else.
  - "pre-work.md": Write a Cline rule that enforces the following points:
    1. Before any work starts, read "docs/forLLMConsumption.md" as well as "docs/ProjectDesign.md". No activity starts without this step.
	2. All designs and implementations must adhere to software best-practices.
	3. Designs/implementations that conflict with or deviate from the content in "docs/forLLMConsumption" or "docs/ProjectDesign.md" must be proactively flagged.
  - "coding-rules.md": Write a Cline rule that enforces the following coding standards/rules for ALL code in this project (no exceptions!): 
    1. Names of fields in JSON must generally accessed through str constants instead of explicitly writing the str into the code (str literals).  For instance, if a JSON object my_json_obj contains a field "content", then the code must not use my_json_obj["content"] but instead define a constant FIELD_CONTENT="content" and then use that constant for accessing the variable with my_json_obj[FIELD_CONTENT].
	2. Use object oriented design principles to divide functions and provide useful abstractions to avoid code duplication. Use abstractions and interfaces where possible. Avoid having one large, unmanageable file with hundreds or thousands of lines of code. Classes must be in a single file with a corresponding name. Abstractions and inheritance must also be visible from the class name / file name.
	3. Break down functionality into multiple functions like it would occur with a library. This allows for easier re-use of code.
	4.Imports inside the "src" directory must be relative!
	5. Provide logging where necessary, but do not use excessive logging for default/successful cases. Use the logging library for generating logging output. 
	6. To improve readability of the code, function calls must - wherever possible - use named parameters at the function call. For instance, if a function f() takes two parameters a and b of type int and str respectively, then the call to the function must be f(a=5, b="abc") instead of f(5,"abc"). This makes code easier to read as is immediately conveys - assuming parameters have been given proper names when writing the function - which parameter gets which value.
	7. When functions indicate an error / malfunction, they must throw an exception. Indicating errors by returning empty lists, zero values or similar return values is not allowed. If the error or malfunction is expected, functions must return None to allow calling functions to handle the error by checking for None. More specifically, all custom exception classes must use details = None as the default when no specific detail parameters are provided, and only create a details dictionary when actual meaningful detail values are available (not None or empty). This ensures consistent behavior across the entire exception hierarchy and provides clear API semantics where None explicitly indicates "no details available" rather than an ambiguous empty dictionary.
	8. Similar exception states must be summarized into a separate class that inherits from the Exceptions base class (or any class that directly or indirectly inherits from this class). The goal is that one can properly classify errors and subsequent handling by using different "except <ExceptionType>:" blocks for error handling code.
	9. The maximum length for a code line is 120 chars.
  - "design-rules": Write a Cline rule that enforces the following rules for designing functionality:
    1. Prior to any design work, the file "docs/ProjectDesign.md" must be re-read in its entirety. No design can occur without this step.
	2. Highest priority must be put to modularization: When a function or class has parts that can be separated, then these must be always separated to function as independent pieces. For instance, if a function f() does two steps s1 and and s2, then f() must be written by defining two sub-function that implement s1 and s2. In general, functions must always strive to be simple and breaking them into modular, parametrizable pieces is key for maintainability of code. Similarly, class design must use inheritance wherever applicable to allow for modularity in the code / design. To achieve the highest re-use possible, before implementing any changes, the documentation for this project in the "docs" directory must be read/understood, so that components that are already implemented/documented are re-used.
	3. Before designing/implementing new classes, modules or functions, always review the functions already available and how these functions could be used for implementing additional functionality or whatever else is requested. If functions need changes to be usable, provide this as an option and review these changes with regards to breaking existing functionality.  Breaking existing functionality should always be avoided and proactively flagged.
	4. Designs must use software design patterns wherever possible. Classes and hierarchies are always to be designed with a combination of design patterns to improve re-usability and maintainability. No exceptions.
  - "file-rules.md": Write a Cline rule that enforces the following file strategy:
    1. Unless explicitly needed, no files should be put into the root directory of the project. Exceptions are global configuration files and files that are expected to be in the root directory such as README.md etc.
	2. The project structure is organized in such a way that the "src" folder contains all production code and "docs" contains all documentation for coding assistants and humans. The "src" directory and any subdirectory must not contain any other code other than the code used for the production code. Temporary files or intermediate code snippets, files or classes do not belong into the "src" folder. If temporary code or other files needs to be created, the "tmp" directory is the place for these. Once an implementation task is done, the tmp should be cleaned up and deleting files form this should must not have any effect on the solution. The "test" folder only has code for Python unit testing (Pytest), the "notebooks" directory has Jupyther notebooks for manual testing & demos. The directories "docs", "images" and "videos" contain documents/documentation, images and videos respectively.
	3. 
  - "post-activity.md": Write a Cline rule that enforces the following actions to be executed after any activity, i.e., before providing a summary that an activity is done:
    1. All unit tests must be run. If any tests fail, additional changes to the new code must be introduced to ensure that the new code is properly tested and works. Implementation is never finished when there are failing tests. Editing must continue until this state is reached. If changes require the removal of previously existing tests, such removal must be explicitly flagged to the user as this is a critical change.
	2. Read the CI workflow for the project and execute all steps defined for checking commits locally, e.g., execute isort, flake8, mypy etc. to ensure compatibility with coding standards. Fix any issues that are identified by this tool before continuing. Ending implementation work before this step concludes without errors is unacceptable.
	3. once all tests succeed (see points 1 and 2), the entire documentation in "docs" needs to be revised and updated. Any changes in the project (whether that is code or design decisions) need to be reflected so that a developer that starts new with producing code for this project will be able to get started quickly. The documentation has to always reflect the latest stages of the code. Deviations between code and documentation are not acceptable.
    4. The documentation also needs to be ready for consumption by coding assistants who may prefer a single file. All relevant documentation must therefore be consolidated for LLM/coding assistant consumption as part of prompts in the file "docs/forLLMConsumption.md" with a version all parts of the documentation that is optimized for LLM consumption.
	5. Review the entire documentation in "docs" and identify deviations between the documentation and the current implementation. Explicitly flag these deviations in the activity summary.
	6. Remove all files in "tmp"
  - "test-rule.md": Write a Cline rule that enforces the following standards around testing and test coverage:
    1. All code related to automated testing belong in the "test" directory, all code for executing manual test scripts belongs in "scripts". The automated testing code covers the production code in "src", automated testing for ode in "cdk" and other directories is not intended. There is no testing code outside of "test" and "scripts".
	2. The project has a testing strategy that distinguishes between unit tests and integration tests. To separate out the integration tests, there must be a directory "test/integration" that contains all test code that requires access external systems for executing the test (e.g., an API or similar systems).
	3. The file structure in "test" mirrors the file structure in "src" (with the exception of "test/integration"), i.e., the tests for "src/package/x.py" belong into "test/package/x.py".
	4. The project aims for an average code coverage of 80% or more. Nevertheless, the critical path of the application in "src" must be fully covered by the automated tests.
	5. Running pytest must be default produce a code coverage report.
- Copy all of the aforementioned files from .clinerules to corresponding directories of the other coding assistants such as:
  - ".amazonq" for Amazon Q.
- Create the following files in ".clinerules/workflows" for Cline workflows (read documentation at https://docs.cline.bot/features/slash-commands/workflows):
  - "ci-workflow.md": Create a workflow that forces Cline to execute the following steps/algorithm:
    1. Read the CI workflow as it is defined for this project.
	2. Execute the steps of the CI workflow locally and collect all issues flagged by tools such as isort, mypy, flake8 etc.; if there are no issues, continue with step 4.
	3. Fix the issues flagged by running the CI workflow locally one by one; go back to step 2.
	4. Run the tests and fix any failing tests. Repeat the test run until there are no failing tests.
  - "test-coverage.md": Create a workflow that forces Cline to execute the following steps/algorithm:
    1. Read the CI workflow definition for this project.
	2. Run the unit tests and determine the test coverage. If the test coverage is below the target defined for the CI workflow, create tests cases until the tes coverage meets the bar set by the CI workflow. Rerun the test coverage measurement and keep generating test cases until the test coverage is sufficiently high.
	3. Run the unit tests again and collect all failing tests.
	4. Fix all errors flagged by failing unit tests or fix the tests that are not implemented properly. Go back to step 3.
  - "documentation.md": Create a workflow that forces Cline to execute the following steps/algorithm:
    1. Read all documentation in "docs" and identify conflicts/contradictions within the documentation.
	2. Compare the documentation with the implementation in "src" and "cdk" and collect all deviations. Collect all pieces of code that are not properly documented, particularly those that are not reflected in "docs/forLLMConsumption".
	3. Review the conflicts in the documentation and resolve these by checking the implementation: the variation that aligns with "docs/ProjectDesign.md" should be used, if this file is insufficient to resolve the conflict, then review the current implementation and align the documentation to the implementation. Collect all of these changes in the actitivity summary at the end of this activity.
	4. Summarize the deviations and develop a plan on how to mitigate them. Provide this as an action plan.
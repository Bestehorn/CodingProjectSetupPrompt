This project needs a proper structure for a professional Python software development project with an automated CI/CD pipeline, testing and coding standards, coding assistant support, documentation and versioning. Hence, you are asked to complete the following:
- Create the directories ".amazonq", ".clinerules", ".clinerules/workflows", ".vscode", "cdk", "config", "docs", "scripts", "src", "test" and "tmp" if they do not already exist
- Create a .gitignore file if it does not exist; if such a file exist, keep the information in it and modify the file so that it has the default entries that keeps generated files of a Python project out of the repository. Add the tmp folder to .gitignore. and all directories that contain AWS CDK related output in "cdk".
- setup a versioning system using setuptools-scm and an auto-generated file "src/_version.py" that serves as a single source of truth for the current version number. All other files must use this file for determining the current version and no other files where the version number is maintained are permitted.
- Create a pyproject.toml file as the single source of truth for project metadata, dependencies, and build configuration:
  - Configure [build-system] with setuptools>=64 and setuptools-scm>=8 as build requirements
  - Configure [tool.setuptools_scm] for automatic version management from git tags
  - Define [project] section with: name, dynamic version reference, description, authors, license, and Python version requirements (e.g., requires-python = ">=3.9")
  - Analyze files in "src", "cdk", "scripts", and "test" directories to identify all dependencies used in the codebase
  - Organize dependencies into appropriate sections:
    * [project.dependencies]: Production runtime dependencies only (what end-users of the package need to run the code)
    * [project.optional-dependencies] with the following groups:
      - dev: All packages/dependencies needed for development of this project, e.g., [pytest, pytest-cov, black, isort, flake8, mypy, bandit, and any other development/testing tools]
      - cdk: All packages/dependencies needed for deploymennt of this project using AWS CDK, e.g., [aws-cdk-lib>=2.0.0, constructs>=10.0.0, awscli, boto3 if needed for CDK constructs]
  - Configure tool-specific settings in their respective sections: [tool.black], [tool.isort], [tool.mypy], [tool.pytest.ini_options]
  - Set max-line-length=120 for all formatting and linting tools in their configuration sections
  - Ensure _version.py and other generated files are excluded from linting tools in their respective configuration sections (e.g., exclude patterns in tool.black, tool.isort, etc.)
  - Include all other metadata required for publishing Python packages (classifiers, keywords, urls, etc.)
- Create an AWS account configuration management system to establish a single source of truth for AWS account IDs, profile names, and regions:
  - (if it does not exist) create "config/aws_accounts.json" as the single source of truth for AWS account mappings. This JSON file maps environment names (e.g., "dev", "staging", "prod") to their corresponding AWS account IDs, AWS CLI profile names, default regions, and descriptions. Example structure:
    ```json
    {
      "accounts": {
        "dev": {
          "account_id": "123456789012",
          "profile": "myproject-dev",
          "region": "us-east-1",
          "description": "Development environment"
        }
      }
    }
    ```
  - (if it does not exist) create "src/aws_config.py" module that provides type-safe, validated access to AWS account configurations. This module must:
    * Implement a singleton pattern (using __new__) to ensure configuration is loaded only once
    * Load and parse the config/aws_accounts.json file
    * Define an AWSAccount dataclass (frozen=True) with fields: account_id, profile, region, description
    * Provide a get_account(env_name: str) method that returns an AWSAccount object and raises ValueError with helpful message listing available environments if the environment name is unknown
    * Provide convenience methods: get_account_id(env_name), get_profile(env_name), get_region(env_name), list_environments()
    * Export a singleton instance 'aws_config' for import by other modules
    * Use proper type hints throughout
  - If config/aws_accounts.json contains sensitive information, add it to .gitignore and create "config/aws_accounts.json.template" with the same structure but placeholder values, documenting the expected format
  - Document in "docs/forLLMConsumption.md" that all AWS account IDs, profile names, and regions must be accessed exclusively through the src/aws_config.py module - hardcoding these values anywhere in the codebase is strictly forbidden. Include usage examples for both CDK code and scripts.
- Determine if this project's repo is on github, gitlab or some other repo hoster and setup a basic CI workflow with the following components depending on which repo hoster is used:
  - Install dependencies: Use `pip install -e ".[dev,cdk]"` to install the project in editable mode with all optional dependency groups defined in pyproject.toml
  - run the tests which are stored in "test/"; the target test coverage for this project is 80%, but the critical path of the application must be fully covered by tests.
  - modern coding standards are automatically checked (black, isort, flake8, mypy); note that generated files such as _version.py must be excluded from checks. We use a maximum code line length of 120 chars for this project. Ensure that this is reflected in both the CI workflow commands and in the tool configuration sections of pyproject.toml.
  - run a security check using bandit
  - All of the three CI components above should be run (ideally, in parallel) and the CI workflow passes, if all of these tests pass. These checks must be run across all files containing code in "cdk", "src", "scripts" and "test"
- If it does not exist, create a virtual environment "venv" for Python for this project. Create a settings.json in ".vscode" so that terminals are automatically started with an activated virtual environment.
- Install the project in editable mode with all dependency groups: Run `pip install -e ".[dev,cdk]"` in the activated virtual environment to ensure all dependencies defined in pyproject.toml are installed
- If it does not exist, create a file "docs/forLLMConsumption.md". This file contains project-relevant information in a format suitable for coding assistants.
- If it does not exist, create a file "docs/ProjectPlan.md". This file contains two main sections: 1. the overall project plan with milestones and key deliverables and 2. a section that lists "todos" that are left for future work as well as open issues.
- If it does not exist, create a file "docs/ProjectDesign.md". This file contains the main design principles and overall architecture of the project.
- Review the Cline documentation for creating rules "https://docs.cline.bot/features/cline-rules" and ensure that you have the best-practices for wirting cline rules!
- Create the following files in ".clinerules" that contain rules for the coding assistant Cline:
  - "use-venv.md": All command line commands must be executed inside the venv. No execution may happen without activated venv.
  - "no-tmp-files-in-root.md": Coding assistants that create intermediate files to organize/automate/streamline their work such as implementation plans, scripts or other such assets must store them in "tmp/". No such files must be stored in the root directory of the project or any other directory. More specifically, implementation plan documents created by Cline with the "/deep-planning" command must be stored on "tmp/" and cannot be stored anywhere else.
  - "pre-work.md": Write a Cline rule that enforces the following points:
    1. Before any work starts, read "docs/forLLMConsumption.md" as well as "docs/ProjectDesign.md". No activity starts without this step.
	  2. All designs and implementations must adhere to software best-practices.
	  3. Designs/implementations that conflict with or deviate from the content in "docs/forLLMConsumption" or "docs/ProjectDesign.md" must be proactively flagged.
  - "coding-rules.md": Write a Cline rule that enforces the following coding standards/rules for ALL code in this project (no exceptions!): 
    1. Names of fields in JSON must generally accessed through str constants instead of explicitly writing the str into the code (str literals).  For instance, if a JSON object my_json_obj contains a field "content", then the code must not use my_json_obj["content"] but instead define a constant FIELD_CONTENT="content" and then use that constant for accessing the variable with my_json_obj[FIELD_CONTENT].
	  2. Use object oriented design principles to divide functions and provide useful abstractions to avoid code duplication. Use abstractions and interfaces where possible. Avoid having one large, unmanageable file with hundreds or thousands of lines of code. Classes must be in a single file with a corresponding name. Abstractions and inheritance must also be visible from the class name / file name.
	  3. Break down functionality into multiple functions like it would occur with a library. This allows for easier re-use of code.
	  4. Imports inside the "src" directory must be relative!
	  5. Provide logging where necessary, but do not use excessive logging for default/successful cases. Use the logging library for generating logging output. 
	  6. To improve readability of the code, function calls must - wherever possible - use named parameters at the function call. For instance, if a function f() takes two parameters a and b of type int and str respectively, then the call to the function must be f(a=5, b="abc") instead of f(5,"abc"). This makes code easier to read as is immediately conveys - assuming parameters have been given proper names when writing the function - which parameter gets which value.
	  7. When functions indicate an error / malfunction, they must throw an exception. Indicating errors by returning empty lists, zero values or similar return values is not allowed. If the error or malfunction is expected, functions must return None to allow calling functions to handle the error by checking for None. More specifically, all custom exception classes must use details = None as the default when no specific detail parameters are provided, and only create a details dictionary when actual meaningful detail values are available (not None or empty). This ensures consistent behavior across the entire exception hierarchy and provides clear API semantics where None explicitly indicates "no details available" rather than an ambiguous empty dictionary.
	  8. Similar exception states must be summarized into a separate class that inherits from the Exceptions base class (or any class that directly or indirectly inherits from this class). The goal is that one can properly classify errors and subsequent handling by using different "except <ExceptionType>:" blocks for error handling code.
	  9. The maximum length for a code line is 120 chars.
  - "design-rules.md": Write a Cline rule that enforces the following rules for designing functionality:
    1. Prior to any design work, the file "docs/ProjectDesign.md" must be re-read in its entirety. No design can occur without this step.
	  2. Highest priority must be put to modularization: When a function or class has parts that can be separated, then these must be always separated to function as independent pieces. For instance, if a function f() does two steps s1 and and s2, then f() must be written by defining two sub-function that implement s1 and s2. In general, functions must always strive to be simple and breaking them into modular, parametrizable pieces is key for maintainability of code. Similarly, class design must use inheritance wherever applicable to allow for modularity in the code / design. To achieve the highest re-use possible, before implementing any changes, the documentation for this project in the "docs" directory must be read/understood, so that components that are already implemented/documented are re-used.
	  3. Before designing/implementing new classes, modules or functions, always review the functions already available and how these functions could be used for implementing additional functionality or whatever else is requested. If functions need changes to be usable, provide this as an option and review these changes with regards to breaking existing functionality.  Breaking existing functionality should always be avoided and proactively flagged.
	  4. Designs must use software design patterns wherever possible. Classes and hierarchies are always to be designed with a combination of design patterns to improve re-usability and maintainability. No exceptions.
  - "file-rules.md": Write a Cline rule that enforces the following file strategy:
    1. Unless explicitly needed, no files should be put into the root directory of the project. Exceptions are global configuration files and files that are expected to be in the root directory such as README.md etc.
	  2. The project structure is organized in such a way that the "src" folder contains all production code and "docs" contains all documentation for coding assistants and humans. The "src" directory and any subdirectory must not contain any other code other than the code used for the production code. Temporary files or intermediate code snippets, files or classes do not belong into the "src" folder. If temporary code or other files needs to be created, the "tmp" directory is the place for these.
	  3. Once an implementation task is done, the tmp should be cleaned up and deleting files from tmp/ should must not have any effect on the solution.
	  4. The "test" folder only has code for Python unit testing (Pytest).
	  5. The "cdk" folder has all code for deploying AWS infrastructure using AWS CDK 
  - "post-activity.md": Write a Cline rule that enforces the following actions to be executed after any activity, i.e., before providing a summary that an activity is done:
    1. All unit tests must be run. If any tests fail, additional changes to the new code must be introduced to ensure that the new code is properly tested and works. Implementation is never finished when there are failing tests. Editing must continue until this state is reached. If changes require the removal of previously existing tests, such removal must be explicitly flagged to the user as this is a critical change.
	  2. Read the CI workflow for the project and execute all steps defined for checking commits locally, e.g., execute isort, flake8, mypy etc. to ensure compatibility with coding standards. Fix any issues that are identified by this tool before continuing. Ending implementation work before this step concludes without errors is unacceptable.
	  3. once all tests succeed (see points 1 and 2), the entire documentation in "docs" needs to be revised and updated. Any changes in the project (whether that is code or design decisions) need to be reflected so that a developer that starts new with producing code for this project will be able to get started quickly. The documentation has to always reflect the latest stages of the code. Deviations between code and documentation are not acceptable.
    4. The documentation also needs to be ready for consumption by coding assistants who may prefer a single file. All relevant documentation must therefore be consolidated for LLM/coding assistant consumption as part of prompts in the file "docs/forLLMConsumption.md" with a version all parts of the documentation that is optimized for LLM consumption.
	  5. Review the entire documentation in "docs" and identify deviations between the documentation and the current implementation. Explicitly flag these deviations in the activity summary.
	  6. Remove all files in "tmp"
  - "test-rule.md": Write a Cline rule that enforces the following standards around testing and test coverage:
    1. All code related to automated testing belong in the "test" directory, all code for executing manual test scripts belongs in "scripts". The automated testing code covers the production code in "src", automated testing for ode in "cdk" and other directories is not intended. There is no testing code outside of "test" and "scripts".
	  2. The project has a testing strategy that distinguishes between unit tests and integration tests. To separate out the integration tests, there must be a directory "test/integration" that contains all test code that requires access external systems for executing the test (e.g., an API or similar systems).
	  3. The file structure in "test" mirrors the file structure in "src" (with the exception of "test/integration"), i.e., the tests for "src/package/x.py" belong into "test/package/x.py".
	  4. The project aims for an average code coverage of 80% or more. Nevertheless, the critical path of the application in "src" must be fully covered by the automated tests.
	  5. Running pytest must be default produce a code coverage report.
  - "manage-dependencies.md": When you add, remove or modify import statements in any of the source files, you must review pyproject.toml to determine if dependency changes are needed in [project.dependencies] or [project.optional-dependencies]. If such changes are needed, you must flag them explicitly and then implement the required changes in pyproject.toml. Remember that production dependencies go in [project.dependencies], development tools go in [project.optional-dependencies.dev], and CDK/infrastructure tools go in [project.optional-dependencies.cdk].
  - "aws-config-rule.md": Write a Cline rule that enforces the following requirements for AWS account configuration:
    1. All AWS account IDs, AWS CLI profile names, and AWS regions must be accessed exclusively through the src/aws_config.py module by importing the aws_config singleton instance.
    2. Hardcoding AWS account IDs, profile names, or region names anywhere in the codebase (in CDK code, scripts, or application code) is strictly forbidden and must be flagged as a critical violation.
    3. When code needs AWS account information, it must use one of the following patterns:
       - `from src.aws_config import aws_config` followed by `aws_config.get_account(env_name)` or convenience methods
       - For CDK: `account = aws_config.get_account("dev")` then use `account.account_id` and `account.region`
       - For scripts with boto3: `profile = aws_config.get_profile("dev")` then `boto3.Session(profile_name=profile)`
    4. Environment names (e.g., "dev", "staging", "prod") should be passed as parameters or environment variables, never hardcoded except in configuration contexts.
    5. If new AWS accounts/environments need to be added, the only file that should be modified is config/aws_accounts.json - no code changes should be required.
    6. Before writing any code that interacts with AWS services, verify that the src/aws_config.py module is being used correctly and that no AWS-specific values are hardcoded.
- Copy all of the aforementioned files from .clinerules to corresponding directories of the other coding assistants such as (do not copy the workflows directory as this is not supported by Amazon Q):
  - ".amazonq" for Amazon Q.
- Create the following files in ".clinerules/workflows" for Cline workflows (read documentation at https://docs.cline.bot/features/slash-commands/workflows):
  - "ci-workflow.md": Create a workflow that forces Cline to execute the following steps/algorithm:
    1. Read the CI workflow as it is defined for this project.
	  2. Execute the steps of the CI workflow locally and collect all issues flagged by tools such as isort, mypy, flake8 etc.; if there are no issues, continue with step 4.
	  3. Fix the issues flagged by running the CI workflow locally one by one; go back to step 2.
	  4. Run the tests and fix any failing tests. Repeat the test run until there are no failing tests.
  - "test-coverage.md": Create a workflow that forces Cline to execute the following steps/algorithm:
    1. Read the CI workflow definition for this project.
	  2. Run the unit tests and determine the test coverage. If the test coverage is below the target defined for the CI workflow, create tests cases until the tes coverage meets the bar set by the CI workflow. Rerun the test coverage measurement and keep generating test cases until the test coverage is sufficiently high.
	  3. Run the unit tests again and collect all failing tests.
	  4. Fix all errors flagged by failing unit tests or fix the tests that are not implemented properly. Go back to step 3.
  - "documentation.md": Create a workflow that forces Cline to execute the following steps/algorithm:
    1. Read all documentation in "docs" and identify conflicts/contradictions within the documentation.
	  2. Compare the documentation with the implementation in "src" and "cdk" and collect all deviations. Collect all pieces of code that are not properly documented, particularly those that are not reflected in "docs/forLLMConsumption".
	  3. Review the conflicts in the documentation and resolve these by checking the implementation: the variation that aligns with "docs/ProjectDesign.md" should be used, if this file is insufficient to resolve the conflict, then review the current implementation and align the documentation to the implementation. Collect all of these changes in the actitivity summary at the end of this activity.
	  4. Summarize the deviations and develop a plan on how to mitigate them. Provide this as an action plan.
    5. Implement the action plan to update the documentation and bring it in line with the current implementation.
